#第一章部分习题

## 1.

> 1.3 设有数据结构（D，R），其中D={d1,d2,d3,d4},R={r},r={(d1,d2),(d2,d3),(d3,d4)}.试按图论中的画法惯例画出其逻辑结构图

线性结构d1-d2-d3-d4

## 2.

> 1.4试仿照三元组的抽象数据类型分别写出抽象数据类别复数和有理数的定义（有理数是其分子，分母均为自然数且分母不为零的分数）。


```c

复数定义 ADT Complex {
数据对象：D={ | e1,e2∈R (R为实数集合) }
数据关系：R={ ，e1是复数的实部，e2是复数的虚部，即：e1+j e2 }
基本操作：
InitComplex(&T,v1,v2)
操作结果：构造复数T，元素e1,e2分别被赋以参数v1,v2的值
DestroyComplex(&T)
初始条件：复数T已存在
操作结果：复数T被销毁
GetComplex(T,i,&e)
初始条件：复数T已存在， i∈{1,2}
操作结果：用e返回复数T的实部或虚部，i=1返回实部, i=2返回虚部
PutComplex(T,i,e)
初始条件：复数T已存在， i∈{1,2}
操作结果：改变复数T实部或虚部为e，i=1改变实部, i=2改变虚部
AddComplex(T1,T2,&T3)
初始条件：复数T1,T2已存在
操作结果：复数T1,T2相加，结果存入复数T3
SubComplex(&T1,T2,&T3)
初始条件：复数T1,T2已存在
操作结果：复数T1,T2相减，结果存入复数T3
MulComplex(&T1,T2,&T3)
初始条件：复数T1,T2已存在
操作结果：复数T1,T2相乘，结果存入复数T3
DivComplex(&T1,T2,&T3)
初始条件：复数T1,T2已存在
操作结果：复数T1,T2相除，结果存入复数T3
} ADT Complex
有理数ADT定义：
ADT Rational_Num {
数据对象：D={ | e1,e2∈I (I为整数集合) }
数据关系：R={ ，e1是有理数的分子，e2是有理数的分母，且e2≠0，即： }
基本操作：
InitRational_Num(&T,v1,v2)
操作结果：构造有理数T，元素e1,e2分别被赋以参数v1,v2的值
DestroyRational_Num(&T)
初始条件：有理数T已存在
操作结果：有理数T被销毁
GetRational_Num(T,i,&e)
初始条件：有理数T已存在， i∈{1,2}
操作结果：用e返回有理数T的分子或分母，i=1返回分子, i=2返回分母
PutRational_Num(T,i,e)
初始条件：有理数T已存在， i∈{1,2}
操作结果：改变有理数T的分子或分母为e，i=1改变分子, i=2改变分母
AddRational_Num(T1,T2,&T3)
初始条件：有理数T1,T2已存在
操作结果：有理数T1,T2相加，结果存入有理数T3
SubRational_Num(&T1,T2,&T3)
初始条件：有理数T1,T2已存在
操作结果：有理数T1,T2相减，结果存入有理数T3
MulRational_Num(&T1,T2,&T3)
初始条件：有理数T1,T2已存在
操作结果：有理数T1,T2相乘，结果存入有理数T3
DivRational_Num(&T1,T2,&T3)
初始条件：有理数T1,T2已存在
操作结果：有理数T1,T2相除，结果存入有理数T3
} ADT Rational_Num

```
## 3.

> 1.6 在程序设计中，常用下列三种不同的出错处理方式

1. 用exit语句终止执行并报告错误
2. 以函数的返回值区别正确返回或错误返回
3. 设置一个整型变量的函数参数以区别正确返回或某种错误返回

试讨论着三种方法的优缺点

> 解释:

- 第一种:用EXIT语句退出,是应用于发生关键性错误,比如你想打开文件并用于读取或写如时,或者动态分配内存空间时发生错误,如果不退出程序在后面对文件描述符或者分配的内存使用的话会发生严重错误,于是在这种错误的时候就必须用EXIT语句退出程序.
- 第二种:当某个函数要完成某个特定任务,并将是否成功完成该任务的结果返回给调用这个函数的程序的时候,比如自己写的一个对SOCKET读写的函数,想往 SOCKET里写1000个字节的数据,如果写入正常则程序就执行下一不操作,如果写入错误则程序要提示用户重试,此时就需要返回不同的值来区别不同的状 态.
- 第三种:用得少,通常用于该函数的执行结果对主进程没有严重的影响的时候.

> 优点:

1. 用exit语句终止执行并报告错误，没有回收占用的资源，但一般不会出现问题，操作系统会自动回收。另外，退出地点太多不利于调试。如果封装一个exit调试函数就另当别论.
2. 以函数的返回值区别正确返回或错误返回比较容易发现错误的地方,不会直接终止程序的运行.但是判断太多,必须人工维护一份错误值列表,尤其是在写了越来越多的函数,错误值也越来越多的时候
3. 这个应该是省去了(2)的人工维护错误值列表. 应该是3个方法里比较好的吧..

> 缺点:

1. 用exit语句终止，并返回报告错误。致命错误这么做，如果是要打开的文件不存在之类的错误就不要exit了
2. 以函数的返回值区别正确返回或错误返回如果你不关心为什么出错的话用这种
3. 设置一个整型变量的函数参数以区别正确返回或某种错误返回需要了解错误的详细原因用这个。

> 注意

exit用于程序执行下去没有意义的时候，如果不是致命错误，尽量不要使用exit退出，大部 分的错误都应该可以用程序作出适当的处理，没有人喜欢用一个动不动就出错退出的软件。是否使用第2，3种处理方式要看在你的上下文中是否有处理这个错误的 足够信息，要看上层是否关心这个错误.

##4.

> 1.7 在程序设计中，可采用下列三种方法实现输入和输出:

1. 通过scanf和printf语句
2. 通过函数的参数显示传递
3. 通过全局变量隐式传递

试讨论这三种方法的优缺点。

1. 用scanf和printf直接进行输入输出的好处是形象、直观，但缺点是需要对其进行格式控制，较为烦琐，如果出现错误，则会引起整个系统的崩溃。 
2. 通过函数的参数传递进行输入输出，便于实现信息的隐蔽，减少出错的可能。 
3. 通过全局变量的隐式传递进行输入输出最为方便，只需修改变量的值即可，但过多的全局变量使程序的维护较为困难。


## 5.
> 1.8 设n为正整数，试确定下列各程序段中前置以记号@的语句的频度:

```c
for(i=1; i<=n; i++){
        for(i=j; j<=i; j++){
        for(k=1; k<=j; k++)
            @ x += delta;   //1+(1+2)+(1+2+3)+(1+2+3+4)+···+[i从1到n]i(i+1)/2
    }
}

-------------------

i=1; j=0;
while(i+j <= n){
   @ if(i>j) j++; //n
    else i++;
}

------------------

x=n; y=0;   //n是不小于1的常数
while(x>=(y+1)*(y+1)){
    @ y++;  //n开方向下取整
}

-------------------

x=91; y=100;
while(y>0){
    @ if(x>100){x -= 10; y--;} //1100
    else x++;
}

```

## 6.

> 1.16 试写一算法，自大至小依次输出顺序输入的三个整数X,Y和Z的值

```c
void Descending(){
    scanf(x, y, z);
    if(x<y){
    temp = x; x = y; y = temp;
    }
    if(y<z){
    temp =z;z=y;
    if(x>=temp)y = temp;
    else{y=x; x=temp;}
    }
    printf(x,y,z);
}
//c语言实现

```


# 7

## k阶斐波那契序列的第m项值的函数算法

K阶斐波那契数列
定义：第k和k+1项为1，前k - 1项为0，从k项之后每一项都是前k项的和
例如：k = 3:，0 0 1 1 2 4 7 13
13 = 2 * 7 - 1
7 = 2 * 4 - 1
4 = 2 * 2 - 0
后一项等于 前一项的2倍 减去 前k+1项。

```c

#include <stdio.h>
#define MAX 1000    //定义数列最大项

//递归实现
int Fb1(int k, int m)
{
    if(m<k) return 0;
    else if((m==k)||(m==k+1)) return 1;
    else return 2*Fb1(k,m-1)-Fb1(k,m-k-1);
}

//循环实现
int Fb2(int k, int m)
{
    int Fn[MAX],i;
    for(i = 0; i < MAX; i++)
    {
        if(i < k - 1)
        {
            Fn[i] = 0;//前k-1项为0
            continue;
        }
        if(i == k - 1 || i == k) //k和k+1项为1
        {
            Fn[i] = 1;
            continue;
        }
        Fn[i] = 2 * Fn[i-1] - Fn[i-k-1];
    }

    return Fn[m-1];
}

int main()
{
    int k,m,result,i;
    scanf("%d%d",&k,&m);
    printf("递归实现: %d ",Fb1(k,m));
    printf("循环实现: %d\n",Fb2(k,m));
    return 0;
}

```

